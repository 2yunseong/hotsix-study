# any 타입은 가능한 한 좁은 범위에서만 사용하기

any는 만병통치약 같기도 하고 독과도 같다. 타입스크립트는 any로 하여금 동적언어와 정적언어를 같이 사용할 수 있게 만들게도 할 수 있다.

하지만 큰 힘에는 큰 책임이 따른다. 개발자는 any 사용에 대한 책임을 져야한다.

그러기 위해선 어떻게 슬기롭게 any를 사용할 수 있을까? 그 중 한가지 방법에 대해 알아보자.

오늘 소개할 방법은, any 타입은 가능한 한 좁은 범위에서만 사용하자는 것이다.

먼저 예시를 보자.

```ts
function onlyParamA(a: A) {
  /* ... */
}
function f() {
  const x = A타입혹은B를리턴하는함수();
  onlyParamA(x); // ERROR
}
```

위 코드는 에러가 난다. 어떻게 해결할 수 있을까? 가장 좋은 방법은 타입 내로잉을 하는 것이다.

하지만 이 챕터에서는 any를 사용해야하는 상황에서 해결하는 방법을 알아보기 위함이기 때문에, any를 사용해서 어떻게 해결할 수 있는지 살펴보자.

어떤 방법이 좋아보이는가? 아래의 정답을 보기 전 스스로 한번 생각해보자.

```ts
// 1번째 방법
function f() {
  const x: any = A타입혹은B를리턴하는함수();
  onlyParamA(x);
}

// 2번째 방법
function f() {
  const x = A타입혹은B를리턴하는함수();
  onlyParamA(x as any);
}
```

이번 제목을 보았다면 쉽게 유추 가능할 것이다. 바로 단언을 통해 선언한 두번째 방법이다.

첫번째 방법은 any로 지정한 x를 함수 전체에서 사용할 수 있는 경우가 있는 반면 두번째 방법은 단순히 함수의 매개변수에 넘겨주는 역할만 한다.

더욱 좁은 범위에 넘겨줌으로써 any가 불러올 부수효과에 대해 방지할 수 있다.

조금 더 설명하자면 첫번째 방법대로 하게되면 x라는 변수가 추후에 어떻게 쓰일 지 모르는 상황에서 x를 any로 취급해버리므로 위험하다.

특히 x를 반환이라도 해버리면.. 이 부수효과는 함수 밖으로도 퍼질 것이다.

혹은 @ts-ignore를 사용해 any를 사용하지 않고 오류를 해결할 수 있다.

```ts
function f() {
  const x = A타입혹은B를리턴하는함수();
  // @ts-ignore
  onlyParamA(x);
}
```

@ts-ignore는 다음 줄의 오류를 무시한다.

그러나 근본적인 원인은 해결한 것이기 아니기 때문에 다른 곳에서 더 큰 문제가 발생할 수 있다.

### 오늘의 결론

- 일단 보통의 상황에서 any는 안쓰면 안쓸수록 좋은 것이다.
- 의도치 않은 타입 손실을 막기 위해, any의 사용범위를 가급적 최대한 줄여야 한다. (굳이 사용해야한다면)
- 함수의 반환타입이 any는 큰 재앙을 불러올 수 있다.
- 강제로 타입 오류를 제거하려면 any대신 ts-ignore가 좋은 선택지일수도 있다.
